#include "sys_intr.h"
#include "xaxivdma.h"
#include "xaxivdma_i.h"
#include "display_demo.h"
#include <stdio.h>
#include "math.h"
#include <ctype.h>
#include <stdlib.h>
#include "xil_types.h"
#include "xil_cache.h"
#include "xparameters.h"
#include "vdma.h"
#include "sleep.h"
#include "xscugic.h"
#include "zynq_interrupt.h"
#include "xgpiops.h"
#include "ff.h"
#include "bmp.h"
#include "xil_cache.h"
#include "xtime_l.h"

u32 *BufferPtr[3];

XScuGic XScuGicInstance;

static FIL fil;
static FATFS fatfs;

static int WriteError;

int wr_index = 0;
int rd_index = 0;

XGpioPs GpioInstance;
volatile int key_flag = 0;
int KeyFlagHold = 1;

unsigned int srcBuffer = (XPAR_PS7_DDR_0_S_AXI_BASEADDR  + 0x1000000);

int Miz702_EMIO_init(void);
void ov5640_init_rgb(void);

int run_triple_frame_buffer(XAxiVdma* InstancePtr, int DeviceId, int hsize,
		int vsize, int buf_base_addr, int number_frame_count,
		int enable_frm_cnt_intr);

static void ReadCallBack(void *CallbackRef, u32 Mask);
static void WriteErrorCallBack(void *CallbackRef, u32 Mask);
static void WriteCallBack(void *CallbackRef, u32 Mask);


int main(void)
{

	u32 Status;

	Miz702_EMIO_init();
	ov5640_init_rgb();


	XAxiVdma InstancePtr;

	xil_printf("Starting the first VDMA \n\r");

	Status = run_triple_frame_buffer(&InstancePtr, 0, 1280, 720,
							srcBuffer, 2, 0);
		if (Status != XST_SUCCESS) {
			xil_printf("Transfer of frames failed with error = %d\r\n",Status);
			return XST_FAILURE;
		} else {
			xil_printf("Transfer of frames started \r\n");
		}
	print("TEST PASS\r\n");

	while (1) ;
		return XST_SUCCESS;
}

/*****************************************************************************/
/*
 * Call back function for write channel
 *
 * This callback only clears the interrupts and updates the transfer status.
 *
 * @param	CallbackRef is the call back reference pointer
 * @param	Mask is the interrupt mask passed in from the driver
 *
 * @return	None
 *
 ******************************************************************************/
static void WriteCallBack(void *CallbackRef, u32 Mask)
{
	if (Mask & XAXIVDMA_IXR_FRMCNT_MASK)
	{

		if (key_flag == 1)
		{
			key_flag = 2;
			return;
		}
		else if (key_flag == 2)
		{
			return;
		}

		if (wr_index == 2)
		{
			wr_index = 0;
			rd_index = 2;
		}
		else
		{
			rd_index = wr_index;
			wr_index++;
		}
		/* Set park pointer */
		XAxiVdma_StartParking((XAxiVdma *)CallbackRef, wr_index, XAXIVDMA_WRITE);
	}
}

/*****************************************************************************/
/*
 * Call back function for write channel error interrupt
 *
 * @param	CallbackRef is the call back reference pointer
 * @param	Mask is the interrupt mask passed in from the driver
 *
 * @return	None
 *
 ******************************************************************************/
static void WriteErrorCallBack(void *CallbackRef, u32 Mask)
{
	if (Mask & XAXIVDMA_IXR_ERROR_MASK)
	{
		WriteError += 1;
	}
}

static void ReadCallBack(void *CallbackRef, u32 Mask)
{
	if (Mask & XAXIVDMA_IXR_FRMCNT_MASK)
	{
		/* Set park pointer */
		XAxiVdma_StartParking((XAxiVdma *)CallbackRef, rd_index, XAXIVDMA_READ);
	}
}















